classdef MAPCsim < handle
    % Traffic class to handle the traffic generated for the STAs 

    properties ( Access = 'private' )
        %%% System-related
        TXOP_duration                           % Duration of a TXOP
        Pn_dBm                                  % Noise in dbm
        noise_power
        Cca                                     % Clear channel assessment in dBm (default Cca = -82 dBm)
        BW                                      % Bandwidth e.g., 20, 40, 80, 160 [in MHz]  
        Nss                                     % Number of spatial streams
        Nsc                                     % Number of subcarriers
        tx_power_ss
            
        %%% Scenario-related
        association                             % Cell array with the list of STAs associated to APs
        channelMatrix
        RSSI_dB_vector_to_export
        MaxTxPower                              % Max TX power per spatial stream [dBm]

        %%% Traffic-related
        event_number = 150000;                   % number of events to explore
        APs_packet_indicator                    % Indicator of AP availability of packets to transmit (used mainly in the backoff process)
        firstPosPosition                        % controls the position  of the first available packet to transmit to each STA 
        lastPosTimestamp                        % controls the timestamp of the last available packet to transmit to each STA (sensitive to sim timeline) 
        lastPosPosition                         % controls the position  of the last available packet to transmit to each STA (sensitive to sim timeline)
        rrobin_DCF_group_selector               % indicates the STA to transmit
        rrobin_CSR_group_selector               % indicates the group to transmit
        tempDelay                               % track the temporal delay 


        %%% Backoff-related
        backoffValues                           % vector which stores the backoff values
        backoffStage                            % vector with the current stage of the backoff of each AP      
        maxBackoffStage                         % maximum backoff stage
        CWmin                                   % contention window
        AIFS                                    % Arbitration Inter Frame Space (depends on the access category)

        
        %%% TXOP-related
        preTX_overheadsDCF                      % DCF overheads before transmission 
        preTX_overheadsCSR                      % CSR overheads before transmission
        DCFoverheads                            % Entire DCF overheads
        CSRoverheads                            % Entire CSR overheads    

        %%% STA selection counter


        %%% For results
        throughput_sim
        
    end

    properties ( Access = 'public' )    
        n_APs                                   % number of APs
        n_STAs                                  % number of stations

        STA_queue_timeline                      % cell array that contains the traffic arrivals, n_STAs x event_number dimensions to the case it is generated by Generator
        STA_queue_state                         % cell array pointer to store the state of the STA queues --> 1: still available
                                                                                                       %  0: already transmitted
        accessCategory = 'BE';                  % to indicate the access category: 'BE', 'VO', 'VI'
                                                                                            
        firstPosTimestamp                       % controls the timestamp of the first available packet to transmit to each STA  
        delivery_timestamp_record               % cell array to store for each STA the timestamp at which every packet is transmitted 
        delay_per_STA                           % stores the delay per STA
        delayvector                             % vector that contains the delay of all STAs
        traffic_type                            % Poisson, Bursty
        timestamp_to_stop                       % simulation duration [in seconds]


        TXOPwinNumber                           % stores each time that an AP wins the contention
        TXOPcollision                           % stores each time an AP has a collision
        STAselectionCounter                     % stores the number of times that each STA is selected
        APcollision_prob                        % stores the collision probability per AP

        %%% MAPC related
        simulation_system
        validationFlag
        CGs_STAs = [];                          % Matrix that stores the C-SR groups
        TxPowerMatrix = [];                     % Matrix with TXPower values
        scheduler = 'MNP'                       % scheduling: - Number of packets: 'MNP' 
                                                %             - Oldest packet: 'OP'
                                                %             - Random selection: 'Random'
                                                %             - TAT selection: 'TAT'
                                                %             - Hybrid selection: 'Hybrid'  

        alpha_ = 1/2;                           % For TAT scheduler- default 1/2
        beta_ = 1/2;                            % For TAT scheduler- default 1/2

        hybridThreshold = 80;                   % hybrid threshold to change the policy between MNP and OP
    end
    
    methods
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function self = MAPCsim(n_APs, n_STAs, association, MaxTxPower, channelMatrix, RSSI_dB_vector_to_export, traffic_type, timestamp_to_stop, ...
                simulation_system, validationFlag, TXOP_duration, Pn_dBm, Cca, BW, Nss, Nsc, preTX_overheadsDCF, preTX_overheadsCSR, DCFoverheads, CSRoverheads) % initialize object (constructor)
                
            %%% Initializing properties
            %%% System-related
            self.TXOP_duration = TXOP_duration;  % Duration of a TXOP
            self.Pn_dBm = Pn_dBm;               % Noise in dbm
            self.noise_power = 10^(Pn_dBm/10);
            self.Cca = Cca;                  % Clear channel assessment in dBm (default Cca = -82 dBm)
            self.BW = BW;                    % Bandwidth e.g., 20, 40, 80, 160 [in MHz]  
            self.Nss = Nss;                    % Number of spatial streams
            self.Nsc = Nsc;
        

            self.n_STAs = n_STAs;                  
            self.n_APs = n_APs;                 
            self.association = association; 
            self.channelMatrix = channelMatrix;
            self.RSSI_dB_vector_to_export = RSSI_dB_vector_to_export;
            self.MaxTxPower = 10^(MaxTxPower/10); 
            
            
            self.traffic_type = traffic_type;
            self.timestamp_to_stop = timestamp_to_stop;

            self.STA_queue_timeline = cell(self.n_STAs,1); 
            self.delivery_timestamp_record = cell(self.n_STAs,1);
            self.STA_queue_state = cell(self.n_STAs,1);

            self.firstPosTimestamp = zeros(n_STAs,1);
            self.firstPosPosition = ones(n_STAs,1);
            self.lastPosTimestamp = zeros(n_STAs,1);
            self.lastPosPosition = zeros(n_STAs,1);
             
            
            self.simulation_system = simulation_system;
            self.validationFlag = validationFlag;
            
            
            self.APs_packet_indicator = zeros(n_APs,1);
            self.backoffStage = zeros(n_APs,1);

            self.TXOPwinNumber = zeros(n_APs,1);
            self.TXOPcollision = zeros(n_APs,1);
            
            self.preTX_overheadsDCF = preTX_overheadsDCF;                  
            self.preTX_overheadsCSR = preTX_overheadsCSR;                     
            self.DCFoverheads = DCFoverheads;                            
            self.CSRoverheads = CSRoverheads;                            

            self.STAselectionCounter = zeros(n_STAs,1);
            
            self.throughput_sim = zeros(n_STAs,1);
            self.delay_per_STA = cell(self.n_STAs,1);
            self.tempDelay = cell(self.n_STAs,1);
            self.delayvector = [];
            self.APcollision_prob = 0;
            
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    end

    methods ( Access = 'private' )

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function UpdateAP(self,sim_timeline)
            %%% Updates a vector that indicates whether each AP has packets to transmit. Each position indicates the AP
            %%% idx
            
            %%% Restarting all APs to zero
            self.APs_packet_indicator = zeros(self.n_APs,1);
            
            %%% Finding APs with packets at sim timelime and putting ones in those AP positions
            for k = 1:self.n_APs
                if sum(self.firstPosTimestamp([self.association{k}]) <= sim_timeline)~=0
                    self.APs_packet_indicator(k,1) = 1;
                end
            end      
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function UpdateSTA(self, STA_rx, rx_vector_pos, sim_timeline, temp_elapsed_time)
            if ~isempty(rx_vector_pos)  % If at least one packet properly received,  update STA properties, otherwise, jump it 

                %%% Updating STA_queue_state
                self.STA_queue_state{STA_rx}(rx_vector_pos) = 0;

                %%% Updating delivery timestamp
                self.delivery_timestamp_record{STA_rx}(rx_vector_pos) = sim_timeline + temp_elapsed_time;

                %%% Update the Position and the Timestamp of the first available packet for each STA
                self.firstPosPosition(STA_rx) = find(self.STA_queue_state{STA_rx}(:),1,'first');
                self.firstPosTimestamp(STA_rx) = self.STA_queue_timeline{STA_rx}(self.firstPosPosition(STA_rx));  % timestamp
                self.tempDelay{STA_rx} = self.delivery_timestamp_record{STA_rx}(1:rx_vector_pos(end)) - self.STA_queue_timeline{STA_rx}(1:rx_vector_pos(end));
            end
            %%% Updating the counter of STA selection
            self.STAselectionCounter(STA_rx) = self.STAselectionCounter(STA_rx) + 1;
                
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [backofftime, TXOPwinner] = Backoff(self)
        
            %%% Backoff process
            APs_with_packets = find(self.APs_packet_indicator==1);
            % fprintf('Backoff values = [ %d %d %d %d ] \n',self.backoffValues);
            % fprintf('APs with packets = [ %d %d %d %d ] \n',APs_with_packets);

            slotnum = min(self.backoffValues(APs_with_packets));                      % stores the current number of backoff slots
            self.backoffValues(APs_with_packets) = self.backoffValues(APs_with_packets) - slotnum;      
            idx = find(self.backoffValues(APs_with_packets)==0);                      % find the position of the device(s) that reach zero
            
            decrementing_backoff = 1;
            collision_counter = 0;
            while decrementing_backoff
                if length(idx)==1           % we have a winner
                    TXOPwinner = APs_with_packets(idx);
                    % fprintf('TXOP winner - AP%d \n',TXOPwinner);
                    self.TXOPwinNumber(APs_with_packets(idx)) = self.TXOPwinNumber(APs_with_packets(idx)) + 1;   % increase the counter of TXOP wins
                    self.backoffValues(APs_with_packets(idx)) = randi([0 (self.CWmin-1)],1,1);    % the TXOP winner restart its backoff counter
                    self.backoffStage(APs_with_packets(idx)) = 0;                     % the backoff stage of the TXOP winner is restarted to stage 1, i.e., ([0 15])                     
                    decrementing_backoff = 0;
                else                        % a collision occurred 
                    % fprintf('Collisioned APs = [ %d %d] \n',idx);
                    for i = 1:length(idx)
                        self.TXOPwinNumber(APs_with_packets(idx(i))) = self.TXOPwinNumber(APs_with_packets(idx(i))) + 1;   % increase the counter of TXOP wins
                        self.TXOPcollision(APs_with_packets(idx(i))) = self.TXOPcollision(APs_with_packets(idx(i))) + 1;   % increase the counter of collisions for this AP 

                        if self.backoffStage(APs_with_packets(idx(i))) < self.maxBackoffStage % Increment the stage until the maximum stage number, m = 6
                            % self.backoffStage(APs_with_packets(idx(i))) = 0;  % single backoff
                            self.backoffStage(APs_with_packets(idx(i))) = self.backoffStage(APs_with_packets(idx(i))) + 1;      % the backoff stage of the collided device is increased to the next stage
                        end
  
                        self.backoffValues(APs_with_packets(idx(i))) = randi([0 (self.CWmin*2^(self.backoffStage(APs_with_packets(idx(i))))-1)],1,1);    % the backoff counter of the collided device is restarted
                        % fprintf('Selected backoff value: %d \n',self.backoffValues(APs_with_packets(idx(i))));                                                                                                                         % The new upper value of the CW = CWmin*2^i - 1
                                                                                                                                                 % The selected value is a random number between 0 and CW
                    end
                    
                    slotnum = slotnum + min(self.backoffValues(APs_with_packets));    % old backoff number + new backoff number
                    collision_counter = collision_counter + 1;   % increase the number of collisions
                    self.backoffValues(APs_with_packets) = self.backoffValues(APs_with_packets) - min(self.backoffValues(APs_with_packets));
                    idx = find(self.backoffValues(APs_with_packets)==0);
                    % fprintf('Backoff values = [ %d %d %d %d ] \n',self.backoffValues);
                end
    
            end
                  
            Tc = 42E-6 + 16e-6 + 36E-6 + self.AIFS + 9e-6;      % collision duration -----> Tc = RTS + SIFS + CTS + AIFS + Te
            backofftime = slotnum*9e-6 + collision_counter*Tc;  % time due to backoff + collisions (if any)


            % fprintf('Slot number = %d \n',slotnum);
            % fprintf('Number of collisions = %d \n',collision_counter);
            % fprintf('Backoff values = [ %d %d %d %d ] \n',self.backoffValues);
            % fprintf('Backof stage = [%d %d %d %d] \n',self.backoffStage');
            % disp('----------------------------------');

            
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
             

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [STA_rx, APs] = schedulingV1(self, sim_timeline, TXOPwinner)
            %%% Scheduling %%%%%%%
            
            switch self.simulation_system
                case 'DCF'
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
                    %%%%%%%      DCF     %%%%%%%%%%

                    switch self.validationFlag
                        case 'yes'
                            %%% Round Robin scheduling. ONLY to compare with Bianchi's model. 
                            %%% Initializing round robin counter
                            if sum(self.firstPosPosition)==self.n_STAs
                                for k = 1:self.n_APs
                                    self.rrobin_DCF_group_selector{k}(:) = [1;zeros(length(self.association{k})-1,1)];
                                end
                            end
                            %%% Selecting the corresponding STA depending on the state of self.rrobin_DCF_group_selector{TXOPwinner}
                            STA_rx = self.association{TXOPwinner}(self.rrobin_DCF_group_selector{TXOPwinner}==1);
                            %%% Updating the round robin counter
                            self.rrobin_DCF_group_selector{TXOPwinner} = circshift(self.rrobin_DCF_group_selector{TXOPwinner},1);

                            % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        otherwise
                            % %%% STA selection. Looks for the STA with the oldest packet in the queue of the TXOP winner
                            [~, STAidx] = min(self.firstPosTimestamp([self.association{TXOPwinner}]));
                            STA_rx = self.association{TXOPwinner}(STAidx);
                    end

                    %%% AP
                    APs = TXOPwinner;
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                otherwise
                    %%% Scheduling the STAs based on:
                    % if self.validationFlag = 'yes', it uses a round robin scheduler, i.e., same tx probability for all devices

                    %%% Looking for STAs with packets available
                    CGs = self.CGs_STAs;
                    per_STA_ScorePackets = zeros(self.n_STAs,1);
                    for j=1:self.n_STAs
                        if self.firstPosTimestamp(j) > sim_timeline     % Jump if the given STA does not have any packets at sim timeline
                            [rowSTA, colSTA] = find(CGs==j);
                            CGs(rowSTA,colSTA) = 0;                % Remove the STA from all the groups where it appears
                            continue
                        end

                        lastPos = find(self.STA_queue_timeline{j}(:)<=sim_timeline,1,'last');
                        firstPos = self.firstPosPosition(j);

                        % range available with packets
                        packet_range = firstPos:lastPos;

                        % initial tx_vector_pos (without analyzing which one is greater between the number of agg frames and the available packets)
                        tx_vector_pos = packet_range(self.STA_queue_state{j}(packet_range) == 1);
                        

                        %%% Updating last position
                        self.lastPosPosition(j) = tx_vector_pos(end);
                        self.lastPosTimestamp(j) = self.STA_queue_timeline{j}(self.lastPosPosition(j));

                        %%% Computing the number of packet available per STA
                        per_STA_ScorePackets(j) = length(tx_vector_pos);
                    end
                    
                    CGs = unique(CGs,'rows','stable');
                    CGs(~any(CGs,2),:) = [];      % removing all-zero rows 

        
                    uni = cell(size(CGs,1),1);
                    ScorePackets = zeros(size(CGs,1),1);       % Scores the number of packets of each group
                    ScoreTimeOldest = zeros(size(CGs,1),1);          % Scores the timestamp of the oldest packet of the group
                    ScoreTAT = zeros(size(CGs,1),1); 

                    for i = 1:size(CGs,1)
                        u = unique(CGs(i,:));
                        u(u==0) = [];
                        uni{i} = u;

                        ScorePackets(i) = sum(per_STA_ScorePackets(u));
                        ScoreTimeOldest(i) = min(self.firstPosTimestamp(u));                            % finds the oldest packet per group
                        
                        if strcmp(self.scheduler,'TAT') || strcmp(self.scheduler,'Hybrid')
                            ei_min = min(self.firstPosTimestamp(u));
                            ei_max = max(self.firstPosTimestamp(u));
                            t = sim_timeline;
                            delta_nt = t - ei_min;
                            Delta_nt = t - ei_max;

                            if length(u) == 1
                                ScoreTAT(i) = delta_nt;
                            else
                                ScoreTAT(i) = delta_nt + self.beta_*(Delta_nt - self.alpha_*delta_nt);
                            end
                        end

                    end
                    
                    switch self.validationFlag
                        case 'yes'
                            if self.rrobin_CSR_group_selector==0 % initializing the round robin CSR selector
                                self.rrobin_CSR_group_selector = zeros(size(self.CGs_STAs,1),1);
                                self.rrobin_CSR_group_selector(1,:) = 1;
                            end


                            %%% Bianchi's paper model
                            % STA = self.association{TXOPwinner}(randi([1 length(self.association{TXOPwinner}(:))],1,1)); %% The TXOP winner randomly selects one of its STAs 
                            % [idx_score, ~] = find(self.CGs_STAs == STA);   % Find the group where the selected STA appears

                            %%% Round Robin
                            idx_score = find(self.rrobin_CSR_group_selector==1);
                            self.rrobin_CSR_group_selector = circshift(self.rrobin_CSR_group_selector,1);
                        otherwise
                            switch self.scheduler
                                case 'MNP' % priority is the group with the highest number of packets
                                    [maxScore, idx_score] = max(ScorePackets);          % find the group with the highest number of packets
                                    equalScoreIdx = find(ScorePackets==maxScore);       % looks for more than one group with the same number of packets among the winners
                                    if length(equalScoreIdx)~=1                         % if true (i.e., a tie, more than one winners)
                                        [~, idx_score_temp] = min(ScoreTimeOldest(equalScoreIdx));
                                        idx_score = equalScoreIdx(idx_score_temp);         % select the group with the oldest packet among the winners
                                    end
                                case 'OP' % priority is the group with the oldest packet
                                    [minOldestScore, idx_score] = min(ScoreTimeOldest);
                                    equalScoreIdx = find(ScoreTimeOldest==minOldestScore);       % looks for more than one group with the same timestamp among the winners (probably due to the same STA in these groups)
                                    if length(equalScoreIdx)~=1                         % if true (i.e., a tie, more than one winners)
                                        [~, idx_score_temp] = max(ScorePackets(equalScoreIdx));
                                        idx_score = equalScoreIdx(idx_score_temp);         % select the group with the highest number of packets among the winners
                                    end
                                case 'Random' % random selection
                                    idx_score = randi([1 length(uni)],1,1);
                                case 'TAT' % CSR TAT 
                                    [~, idx_score] = max(ScoreTAT);
                                case 'Hybrid' % CSR hybrid
                                    if ~isempty([self.tempDelay{:}])
                                        prcentile = prctile([self.tempDelay{:}],self.hybridThreshold);
                                        % prcentile = 5E-3;
                                    else
                                        prcentile = 5E-3;
                                    end

                                    if delta_nt > prcentile % OP
                                        [minOldestScore, idx_score] = min(ScoreTimeOldest);
                                        equalScoreIdx = find(ScoreTimeOldest==minOldestScore);       % looks for more than one group with the same timestamp among the winners (probably due to the same STA in these groups)
                                        if length(equalScoreIdx)~=1                         % if true (i.e., a tie, more than one winners)
                                            [~, idx_score_temp] = max(ScorePackets(equalScoreIdx));
                                            idx_score = equalScoreIdx(idx_score_temp);         % select the group with the highest number of packets among the winners
                                        end
                                    else    % MNP
                                        [maxScore, idx_score] = max(ScorePackets);          % find the group with the highest number of packets
                                        equalScoreIdx = find(ScorePackets==maxScore);       % looks for more than one group with the same number of packets among the winners
                                        if length(equalScoreIdx)~=1                         % if true (i.e., a tie, more than one winners)
                                            [~, idx_score_temp] = min(ScoreTimeOldest(equalScoreIdx));
                                            idx_score = equalScoreIdx(idx_score_temp);         % select the group with the oldest packet among the winners
                                        end
                                    end
                            end
                    end

                    %%% Getting the resulting STAs for this TXOP
                    STA_rx = sort([uni{idx_score}]');
                    
        
                    %%% Finding the APs which these STAs are associated to:
                    % Initialize a vector to store the positions
                     APs = zeros(size(STA_rx));
                    
                    % Loop through each value in STA_rx
                    for i = 1:length(STA_rx)
                        % Find the position where the current value appears in the association cell array
                        idx = find(cellfun(@(x) ismember(STA_rx(i), x), self.association), 1);
                        
                        % Store the position in the vector
                        APs(i) = idx;
                    end
            end
                
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function elapsed_time = TXtimeCalc(self, STA_rx, APs, sim_timeline, data_tx_time)
            %%% TX calculation. Computes the time (temp_elapsed_time) spent by the given STA_rx and APs to transmit 
            %%% as well as the number of transmitted packets (transmitted_packets).

            %%%%%%%%% Transmissions 
            %%% Initializing tx parameters
            
            agg_packets = zeros(length(STA_rx),1);
            lastPos = zeros(length(STA_rx),1);
            firstPos = zeros(length(STA_rx),1);
            
            tx_Packets = zeros(length(STA_rx),1);
            received_packets = zeros(length(STA_rx),1);
            temp_elapsed_time = zeros(length(STA_rx),1);

            H = self.channelMatrix(STA_rx, APs);

            if length(STA_rx) == 1
                % %%% No TPC (Maximum tx power)
                P = self.MaxTxPower;
            else
                rows = find(sum(ismember(self.CGs_STAs,STA_rx),2) == length(STA_rx));
                idx = rows(sum(self.CGs_STAs(rows,:)~=0,2) == length(STA_rx));
                P = self.TxPowerMatrix(idx,APs)';
            end
            SINR_db = 10*log10((P .* diag(H)) ./ (self.noise_power + sum(H .* P', 2) - diag(H) .* P));

            MCS = NaN(length(STA_rx),1);
            N_bps = NaN(length(STA_rx),1);
            Rc = NaN(length(STA_rx),1);
            
            %%% Computing the transmitted_packets and the time spent to tx them (temp_real_time)
            for k = 1:length(STA_rx)  
                [MCS(k,1), N_bps(k,1), Rc(k,1)] = MCS_cal_PER_001(SINR_db(k,1));
                
                %%% Validations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% MCS validation.  MCS(k,1) = NaN, means that the SINR is under the minimum allowed
                if ~isnan(MCS(k,1)) 
                    Pe = 1E-2;
                else
                MCS(k,1) = 0;
                N_bps(k,1) = 1;
                Rc(k,1) = 1/2;
                Pe = 1;   % error probability
                % error('Not a valid MCS');   
                end


                %%% Max number of A-MPDUs (packets allowed due to SINR)
                agg_packets(k,1) = tx_packets(self.Nsc, N_bps(k,1), Rc(k,1), self.Nss, data_tx_time);

                %%% Number of packets validation
                if agg_packets(k,1) > 1024
                    error('Imposible to tx more than 1024 MPDUs')
                end

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
                %%% Find the real number of packets to be transmitted ----> packets in queue vs packets allowed (due to SINR)
                lastPos(k) = find(self.STA_queue_timeline{STA_rx(k)}(:)<=sim_timeline,1,'last');
                firstPos(k) = self.firstPosPosition(STA_rx(k));
                
                % range available with packets
                packet_range = firstPos(k):lastPos(k);

                % initial tx_vector_pos (without analyzing which one is greater between the number of agg frames and the available packets)
                tx_vector_pos = packet_range(self.STA_queue_state{STA_rx(k)}(packet_range) == 1);
                
                % real number of tx packets
                tx_Packets(k) = min(length(tx_vector_pos), agg_packets(k));

                % updating the real number of tx packets
                tx_vector_pos = tx_vector_pos(1:tx_Packets(k));
                
                %%%%%%% Validations  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%% tx_Packets(k) == length(tx_vector_pos)
                if tx_Packets(k) ~= length(tx_vector_pos)
                    error('Check the code. tx_Packets(k) must be equal to length(tx_vector_pos)')
                end

                %%% This avoids to transmit more packets that the total number of packets of the STA_queue_timeline
                if tx_vector_pos(end) > length(self.STA_queue_timeline{STA_rx(k)}(:))
                    tx_Packets(k,1) = length(self.STA_queue_timeline{STA_rx(k)}(:)) - firstPos(k);
                end
                
                %%% To verify that the arrival time of the last transmitted packet is lower than sim_timeline
                if self.STA_queue_timeline{STA_rx(k)}(tx_vector_pos(end)) > sim_timeline
                    error('Not possible to transmit this packet yet: its arrival time is higher than sim_timeline');
                end
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                %%% Real time spent to transmit data
                switch self.validationFlag 
                    case 'yes' 
                        received_packets(k,1) = tx_Packets(k,1);
                        temp_elapsed_time(k,1) = data_tx_time;
                    otherwise
                        received_packets(k,1) = binornd(tx_Packets(k,1),(1-Pe)); % binomial distribution where max_numPackets is the number of trials 
                                                                                   % and success probability = 1 - PER ---> PER = 1E-2
                        lost_packets_pos = randperm(length(tx_vector_pos), tx_Packets(k,1) - received_packets(k,1));
                        rx_vector_pos = tx_vector_pos;
                        
                        % %%% Re-transmissions verbose
                        % if (tx_Packets(k,1) - received_packets(k,1)) ~= 0
                        %     fprintf('Re-transmission for STA%d \n',STA_rx(k));
                        %     fprintf('Packet ID: %d \n',rx_vector_pos(lost_packets_pos));  
                        % end

                        rx_vector_pos(lost_packets_pos) = [];
                        temp_elapsed_time(k,1)  = elapsed_time_tx(self.Nsc, N_bps(k,1), Rc(k,1), self.Nss, tx_Packets(k,1)); % tx packets could be different to rx packets (some losses) 
                end
                
                %%% Updating the position of the first valid packet for each STA and updating delivery_timestamp_record
                self.UpdateSTA(STA_rx(k),rx_vector_pos, sim_timeline, temp_elapsed_time(k,1));
            end      

            %%% elapsed_time is the max among all  
            elapsed_time = max(temp_elapsed_time);

        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function TrafficAnalysis(self)

            %%% Analysis of the results
            for j=1:self.n_STAs      % per STA Analysis
                % Find the last transmitted packet
                last_tx_packet = find(self.STA_queue_state{j}(:)==0,1,'last');

                % Find the packets newer than the last transmitted one that weren't transmitted yet
                no_tx_packets = find(self.STA_queue_state{j}(1:last_tx_packet)==1);

                % Remove these packets from the queue and from the delivery list
                self.delivery_timestamp_record{j}(no_tx_packets) = [];
                self.STA_queue_timeline{j}(no_tx_packets) = [];
                self.STA_queue_state{j}(no_tx_packets) = [];

                self.delay_per_STA{j} = self.delivery_timestamp_record{j}(1:(last_tx_packet - length(no_tx_packets))) -  self.STA_queue_timeline{j}(1:(last_tx_packet - length(no_tx_packets)));
                
                % Validation for negative or equal zero delay
                if sum(self.delay_per_STA{j} <= 0) ~= 0
                    error('Delay cannot be negative or equal zero');
                end

                self.delayvector = [self.delayvector;self.delay_per_STA{j}']; 
                % self.throughput_sim (j) = 12E3*(last_tx_packet - length(no_tx_packets))/(1E6*(self.delivery_timestamp_record{j}(last_tx_packet - length(no_tx_packets))));
            end

            
            for jj=1:self.n_APs      % Per AP analysis        
                self.APcollision_prob(jj) = self.TXOPcollision(jj)./self.TXOPwinNumber(jj); 
            end
            

        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    end  
    
    methods ( Access = 'public' )

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function Init(self)
            %%% Initializing STAs
            for i=1:self.n_STAs
                self.firstPosTimestamp(i,1) = self.STA_queue_timeline{i}(1);     % The first timestamp in the STA queue timeline
                self.firstPosPosition(i,1) = 1;        % The first packet available for each STA is the number 1

                self.delivery_timestamp_record{i}(:) = NaN(length(self.STA_queue_timeline{i}),1);
                self.STA_queue_state{i} = ones(1,length(self.STA_queue_timeline{i}));  %  Initializing the queue state matrix
            end 
            
            switch self.accessCategory
                case 'VO'
                    self.CWmin = 4;              % CWmin = 3 , CWmax = 7
                    self.maxBackoffStage = 1;    % {0,1}
                    AIFSN = 2;
                case 'VI'
                    self.CWmin = 8;              % CWmin = 7 , CWmax = 15
                    self.maxBackoffStage = 1;    % {0,1}
                    AIFSN = 2;
                case 'BE'
                    self.CWmin = 16;
                    self.maxBackoffStage = 6;
                    AIFSN = 3;
            end
            self.backoffValues = randi([0 self.CWmin-1],1,self.n_APs);
            self.AIFS = AIFSN*9e-6 + 16e-6;  % AIFSN*slotTime + SIFS

        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function Start(self)

            %%% Line of time
            sim_timeline = 0;

            %%% Simulation
            while sim_timeline < self.timestamp_to_stop

                %%% to forward the simulation timeline up to the next packet arrival
                if min(self.firstPosTimestamp) > sim_timeline
                    sim_timeline = min(self.firstPosTimestamp);
                end

                %%% Update the buffer state of APs, to indicate whether they have packets or not to tx
                self.UpdateAP(sim_timeline);

                %%% Contention process. Backoff and TXOP winner
                [backofftime, TXOPwinner] = self.Backoff();          % backoff time can also include time due to collisions

                %%% Moving forward the simulation timeline, i.e., after backoff and collisions (if any)
                sim_timeline = sim_timeline + backofftime;

                %%% Scheduling. STAs and APs selection for the ongoing TXOP depending on the simulation_system employed, i.e., DCF or CSR
                [STA_rx, APs] = self.schedulingV1(sim_timeline, TXOPwinner);
                

                %%% Moving forward the simulation timeline, after pre tx overheads that depend on whether the TXOP will be single or
                %%% coordinated
                if strcmp(self.simulation_system,'DCF') % for DCF
                    sim_timeline = sim_timeline + self.preTX_overheadsDCF; % moving the timeline up to: sim_timeline + RTS + SIFS + CTS + SIFS + time_preamble_data
                    data_tx_time = self.TXOP_duration - self.DCFoverheads;
                else % for ST and CSR
                    sim_timeline = sim_timeline + self.preTX_overheadsCSR; % moving the timeline up to: sim_timeline + TRTS + TSIFS + TCTS + TSIFS + T_MAPC_TXOP + TSIFS + time_preamble_data;
                    data_tx_time = self.TXOP_duration - self.CSRoverheads;
                end

                %%% TX calculation. Computes the elapsed time due to the transmission. Updates also the per STA traffic queues
                %%% depending on the number of transmitted packets
                elapsed_time = self.TXtimeCalc(STA_rx, APs, sim_timeline, data_tx_time);

                %%% Updating the simulation timeline
                sim_timeline = sim_timeline + elapsed_time + 159E-06;   % 159us: TSIFS + TBACK + DIFS + Te;

            end

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %%%%%%%% Analysis

            self.TrafficAnalysis();

        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    end
end  
